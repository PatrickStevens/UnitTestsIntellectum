using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;

namespace DemoLib
{
  // access modifiers aren't built for real protection. They are built to determine the API that's available when 
  // you're using the types. Reflection however, works directly off the modifier. If it's public - then with reflection
  // it's public. It doesn't matter the hierarchy. Remember, reflection can actually access private members.
  // Further, constructors don't inherit the modifier of the class. The default constructor - that's generated by the
  // compiler if you don't define it - is always public.
  //
  // so public CTOR in internal class is "internal" for API (non-reflection) invocation, but to reflection it is "public"
  // as hierarchy is not considered. Since WPF bindings use reflection, then it is important to appreciate that the
  // properties must be public (XAML bindings ONLY consider public methods) but does not mean that class (VMs) need to
  // be public, and VMs (and Views) in fact should not be public, should both be internal.
  //

  public class Bar
  {
    private static int _sBarID = 0;

    public Bar()
    {
      ID = ++_sBarID;
    }

    int ID { get; set; }
  }

  public abstract class FooAbstract
  {
    protected Bar MyProperty { get; set; }

    // Constructor is only need in concrete classes of FooAbstract
    protected FooAbstract(Bar barProperty)
    {
      MyProperty = barProperty;
    }

    public static FooAbstract ReflectCTOR() { return null; }

    protected static T ReflectCTORBase<T>(Bar barProperty, BindingFlags flags = BindingFlags.Instance | BindingFlags.Public) where T : FooAbstract
    {
      return (T)Activator.CreateInstance(
        typeof(T),
        flags,
        null,
        new object[] { barProperty },
        null);
    }
  }

  internal class FooInternalInternal : FooAbstract
  {
    // Internal is enough, public is not necessary
    internal FooInternalInternal(Bar barProperty)
      : base(barProperty)
    { }

    public static new FooAbstract ReflectCTOR()
    {
      return ReflectCTORBase<FooInternalInternal>(new Bar(), BindingFlags.Instance | BindingFlags.NonPublic);
    }
  }

  internal class FooInternalPublic : FooAbstract
  {
    // Internal is enough, public is not necessary
    public FooInternalPublic(Bar barProperty)
      : base(barProperty)
    { }

    public static new FooAbstract ReflectCTOR()
    {
      return ReflectCTORBase<FooInternalPublic>(new Bar());
    }
  }

  public static class FooTest
  {
    public static List<FooAbstract> ReflectFoos()
    {
      var foos = new List<FooAbstract>();
      foos.Add(FooInternalInternal.ReflectCTOR());
      foos.Add(FooInternalPublic.ReflectCTOR());

      return foos;
    }
  }
}
